<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Art by Brandon Makin</title>
    <link rel="stylesheet" href="art.css">
    <script type="text/javascript" src="js/paper-full.min.js"></script>
    <script type="text/paperscript" canvas="canvas">
      //declare variables:
      //...

        //List artwork:

        var art = ['art/001.jpg',"art/002.jpg","art/003.jpg","art/004.jpg","art/005.jpg","art/006.jpg","art/007.jpg","art/008.jpg","art/009.jpg","art/010.jpg","art/011.jpg"]
        var artUnused = art.slice(); //which art is left undisplayed.
        var artworkCount = art.length;

        var circles = [];
        var count = 0;
        var sorted = false;

        var width = view.center.x * 2;
        var height = view.center.y * 2;

        var testCircle = new Circle(view.center.x+200, view.center.y+100)

        //create and name layers:
        //...
          var baseLayer = project.activeLayer;
          var specialLayer = project.addLayer(new Layer());
          var artLayers = [];
          for (var i = 0; i < artworkCount; i++) {
            artLayers[i] = project.addLayer(new Layer());
          }
          baseLayer.activate();

      //draw loop:
      function onFrame() {
        //Add circles:
        if(circles.length < 100) {

          if (count < 7 || count > 20) {
            for (var repeat = 0; repeat < 3; repeat++) {
              var newC = newCircle();
              if (newC != null) {
                circles.push(newC);
              }
            }
          }
          count++;
        }

        //Grow and display circles:
        for (var i = 0; i < circles.length; i++) {
          var c = circles[i];

          //check whether to stop growing:
          //...
            if (c.isHittingEdge() == true) {
              c.growing = false;
            }
            else {
              for (var j = 0; j < circles.length; j++) {
                var other = circles[j];
                var distance = dist(c.x, c.y, other.x, other.y)
                if (c != other && distance <= c.radius + other.radius + 4) {
                  c.growing = false;
                }
              }
            }

          //grow circles if they can grow:
          c.grow();

          //hide tiny circles and delete tiny non-growing circles:
          //...
            if (c.radius <= 5) {
              if (c.growing == false) {
                c.circle.remove();
                circles.splice(i,1);
              }
              else {
                c.circle.opacity = 0;
              }
            } else {
              c.circle.opacity = 1;
            }
        }

        var animationFinished = true;
        if (circles.length < 80) {
          for (var i = 0; i < circles.length; i++) {
            if (circles[i].growing == true) {
              animationFinished = false;
              break;
            }
          }
        }
        if (animationFinished) {
          if (!sorted) {
            sortByRadiusDescending();
            sorted = true;
          }
          for (var i = 0; i < artworkCount; i++) {
            var c = circles[i];

            c.mask = c.circle.clone()
            artLayers[i].addChildren([c.circle, c.image, c.mask]);
            c.mask.clipMask = "true";
            c.image.opacity = (c.image.opacity >= .95) ? 1 : c.image.opacity + 0.1;
            //c.circle.strokeWidth = 1;
            //c.circle.strokeColor = "black";

            if ((c.image.source).match(/\/blank.bmp$/) != null) {
              c.image.source = artUnused.splice( (Math.round( Math.random() * artUnused.length )), 1 );
              c.image.onLoad = function() {
                //console.log(this + ": " + this.image.width + 'x' + this.image.height);
                var shortRadius = (this.image.width < this.image.height) ? this.image.width/2 : this.image.height/2;
                //console.log(this);
                this.scale(1/shortRadius);
              }
              //c.image.fitBounds(new Size(10,10));
              //console.log(c.image.size);
            }
            c.image.fillColor = "black";
          }
        }

      }

      //get new Circle:
      function newCircle() {
        var x = Math.round(Math.random()*width);
        var y = Math.round(Math.random()*width);

        var valid = true;
        for (var i = 0; i < circles.length; i++) {
          var c = circles[i];
          var distance = dist(x, y, c.x, c.y)
          if (distance < c.radius) {
            valid = false;
            break;
          }
        }

        if(valid) {
          return new Circle(x, y, "");
        } else {
          return null;
        }
      }

      //circle class:
      function Circle(x, y) {
        this.x = x;
        this.y = y;
        this.image = new Raster("blank.bmp"); //the image as a raster
          this.image.position = new Point(x,y);
          //this.image.scale(.002);
          this.image.opacity = 0;
        this.radius = 1;
        this.growing = true;
        this.circle = new Path.Circle({
            center: new Point(this.x, this.y),
            radius: this.radius,
            fillColor: new Color((Math.random() * 0.7 + 0.25))
        });
        this.mask = null;

        this.grow = function() {
          if (this.growing == true) {
            var oldRadius = this.radius;
            this.radius += 4;
            this.circle.scale(this.radius / oldRadius);
            this.image.scale(this.radius / oldRadius);
          }
        }

        this.isHittingEdge = function() {
          return (this.x + this.radius >= width - 4 || this.x - this.radius <= 0 + 4 || this.y + this.radius >= height - 4 || this.y - this.radius <= 0 + 4)
        }


      }

      //sorts the circles by radius, from biggest to smallest radius.
      function sortByRadiusDescending() {
        var newCircles = [];
        while (circles.length > 0) {
          //find smallest value:
          var smallest = 0;
          for (var i = 1; i < circles.length; i++) {
            if (circles[i].radius > circles[smallest].radius) {
              smallest = i;
            }
          }
          var smallestCircleLeft = circles.splice(smallest,1); //remove the circle at index "smallest" from circles.
          newCircles.push(smallestCircleLeft[0]); //add the smallestCircleLeft to the front of the array.
          //Will continue until only the biggest circle is left and is added to newCircles.
        }
        circles = newCircles;
        //console.log(newCircles);
      }

      //get distance between two points:
      var dist = function(x1, y1, x2, y2) {
        return Math.sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) )
      }

    </script>
  </head>
  <body>
    <div id="showSlides">
      <a href=""><p> CLICK </p></a>
    </div>
    <iframe class="slideshow" scrolling=""src="slideshow.html#firstSlide"></iframe>
    <canvas id="canvas" resize stats></canvas>
  </body>
</html>
